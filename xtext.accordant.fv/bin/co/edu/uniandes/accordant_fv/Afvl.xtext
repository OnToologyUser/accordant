// automatically generated by Xtext
grammar co.edu.uniandes.accordant_fv.Afvl with org.eclipse.xtext.common.Terminals

// generate test "http://org/xtext/accordant/FVDsl"
import "http://uniandes.accordant.functional"
import "http://uniandes.accordant.requirement" as rq
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

FunctionalView returns FunctionalView:
	'FunctionalView'
	name=ID
	'use' 'project' project=[rq::Project]
	'{'
	'Components' '{' comps+=Component ("," comps+=Component)* '}'
	'Connectors' '{' conns+=Connector ("," conns+=Connector)* '}'
	'}';

Connector returns Connector:
	Stream | Adaptor | Distributor | Event | ProcedureCall;

Component returns Component:
	Transformer | Estimator | Ingestor | Sink;

EString returns ecore::EString:
	STRING | ID;

EInt returns ecore::EInt:
	'-'? INT;

Port returns Port:
	{Port}
	'Port' name=ID ':' type=PortType?
	('fields' ':' '{' fields+=Field ("," fields+=Field)* '}')?;

Role returns Role:
	{Role}
	'Role' name=ID ':' type=RoleType? '->' port=[Port]?;

enum DeliveryGuarantee returns DeliveryGuarantee:
	BEST_EFFORT='BEST_EFFORT' | AT_LEAST_ONCE='AT_LEAST_ONCE' | AT_MOST_ONCE='AT_MOST_ONCE' | EXACTLY_ONCE='EXACTLY_ONCE';

enum SyncType returns SyncType:
	ASYNC='ASYNC' | SYNC='SYNC';

enum PortType returns PortType:
	REQUIRED='REQUIRED' | PROVIDED='PROVIDED';

enum RoleType returns RoleType:
	OUT='OUT' | IN='IN';

enum NotificationModel returns NotificationModel:
	POLLED='POLLED' | PUBSUB='PUBSUB' | QUEUED='QUEUED' | CENTRAL='CENTRAL';

enum Buffering returns Buffering:
	BUFFERED='BUFFERED' | UNBUFFERED='UNBUFFERED';

enum Throughput returns Throughput:
	ATOMIC='ATOMIC' | HIGH_ORDER='HIGH_ORDER';

	//ConnProps returns DeliveryModel | SyncType | NotificationModel
Stream returns Stream:
	'Stream'
	name=ID
	'{'
	('delivery' ':' delivery=DeliveryGuarantee)?
	('sync' ':' synct=SyncType)?
	('notification' ':' notification=NotificationModel)?
	('buffering' ':' buffering=Buffering)?
	('throughput' ':' throughput=Throughput)?
	('props' ':' props=EString)?
	('decision' ':' decision=[rq::ArchDecision])?
	'roles' ':' '{' roles+=Role ("," roles+=Role)* '}'
	'}';

Adaptor returns Adaptor:
	'Adaptor'
	name=ID
	'{'
	('delivery' ':' delivery=DeliveryGuarantee?)
	('sync' ':' synct=SyncType)?
	('notification' ':' notification=NotificationModel)?
	('buffering' ':' buffering=Buffering)?
	('throughput' ':' throughput=Throughput)?
	('props' ':' props=EString)?
	('decision' ':' decision=[rq::ArchDecision])?
	'roles' '{' roles+=Role ("," roles+=Role)* '}'
	'}';

Distributor returns Distributor:
	'Distributor'
	name=ID
	'{'
	('delivery' ':' delivery=DeliveryGuarantee)?
	('sync' ':' synct=SyncType)?
	('notification' ':' notification=NotificationModel)?
	('buffering' ':' buffering=Buffering)?
	('throughput' ':' throughput=Throughput)?
	('props' ':' props=EString)?
	('decision' ':' decision=[rq::ArchDecision])?
	'roles' '{' roles+=Role ("," roles+=Role)* '}'
	'}';

Event returns Event:
	'Event'
	name=ID
	'{'
	('delivery' ':' delivery=DeliveryGuarantee)?
	('sync' ':' synct=SyncType)?
	('notification' ':' notification=NotificationModel)?
	('buffering' ':' buffering=Buffering)?
	('throughput' ':' throughput=Throughput)?
	('props' ':' props=EString)?
	('decision' ':' decision=[rq::ArchDecision])?
	'roles' ':' '{' roles+=Role ("," roles+=Role)* '}'
	'}';

ProcedureCall returns ProcedureCall:
	'ProcCall'
	name=ID
	'{'
	('delivery' ':' delivery=DeliveryGuarantee)?
	('sync' ':' synct=SyncType)?
	('notification' ':' notification=NotificationModel)?
	('buffering' ':' buffering=Buffering)?
	('throughput' ':' throughput=Throughput)?
	('props' ':' props=EString)?
	('decision' ':' decision=[rq::ArchDecision])?
	'roles' ':' '{' roles+=Role ("," roles+=Role)* '}'
	'}';

enum ProcessingModel returns ProcessingModel:
	STREAM='STREAM' | BATCH='BATCH' | MICROBATCH='MICROBATCH';

enum AccessType returns AccessType:
	HTTP='HTTP' | DATABASE='DATABASE' | FILESYSTEM='FILESYSTEM' | HDFS='HDFS';

Transformer returns Transformer:
	'Transformer'
	name=ID
	'{'
	('procModel' ':' procModel=ProcessingModel)?
	('delivery' ':' delivery=DeliveryGuarantee)?
	('pmml' ':' pmml=EString)?
	('decision' ':' decision=[rq::ArchDecision])?
	'ports' ':' '{' ports+=Port ("," ports+=Port)* '}'
	'}';

Estimator returns Estimator:
	'Estimator'
	name=ID
	'{'
	('procModel' ':' procModel=ProcessingModel)?
	('delivery' ':' delivery=DeliveryGuarantee)?
	('pmml' ':' pmml=EString)?
	('decision' ':' decision=[rq::ArchDecision])?
	'ports' ':' '{' ports+=Port ("," ports+=Port)* '}'
	'}';

Ingestor returns Ingestor:
	'Ingestor'
	name=ID
	'{'
	'type' ':' type=AccessType
	('procModel' ':' procModel=ProcessingModel)?
	('delivery' ':' delivery=DeliveryGuarantee)?
	('conn' ':' conn=EString)?
	('format' ':' format=EString)?
	('props' ':' props=EString)?
	('decision' ':' decision=[rq::ArchDecision])?
	'ports' ':' '{' ports+=Port ("," ports+=Port)* '}'
	'}';

Sink returns Sink:
	'Sink'
	name=ID
	'{'
	'type' ':' type=AccessType
	('procModel' ':' procModel=ProcessingModel)?
	('delivery' ':' delivery=DeliveryGuarantee)?
	('conn' ':' conn=EString)?
	('format' ':' format=EString)?
	('props' ':' props=EString)?
	('decision' ':' decision=[rq::ArchDecision])?
	'ports' ':' '{' ports+=Port ("," ports+=Port)* '}'
	'}';

Field returns Field:
	name=ID ':' dtype=EString 'order' order=TOSHORT;
	
TOSHORT returns ecore::EShort:
	INT
;

//DType returns ecore::EDataType:
//	
//;
